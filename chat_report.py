#!/usr/bin/env python3
import argparse
import csv
import json
import pathlib
import re
from collections import Counter
from datetime import datetime, timezone
from html import escape
from typing import Iterable, List, Dict, Any

HTML_TEMPLATE = """
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Chat Report</title>
<style>
  body {{ font-family: "Segoe UI", sans-serif; margin:0; padding:0; background:#f7fafc; color:#111; }}
  header {{ background:#111827; color:#fff; padding:24px; }}
  header h1 {{ margin:0 0 8px; }}
  header p {{ margin:0; opacity:.8; }}
  main {{ padding:24px; }}
  .section {{ background:#fff; border-radius:12px; padding:20px; margin-bottom:20px; box-shadow:0 10px 40px rgba(15,23,42,.08); }}
  .section h2 {{ margin-top:0; }}
  .section h3 {{ margin-top:16px; margin-bottom:8px; font-size:1.1rem; }}
  .metrics-grid {{ display:grid; grid-template-columns:repeat(auto-fit,minmax(200px,1fr)); gap:16px; }}
  .metric-card {{ background:#eef2ff; padding:14px; border-radius:10px; }}
  .metric-card strong {{ display:block; font-size:1.5rem; }}
  .filters {{ display:flex; flex-wrap:wrap; gap:12px; margin-bottom:12px; }}
  .filters input, .filters button, .pagination-controls button {{ padding:10px 14px; border-radius:8px; border:1px solid #cbd5f5; font-size:1rem; background:#fff; cursor:pointer; }}
  .filters button:disabled, .pagination-controls button:disabled {{ opacity:.6; cursor:not-allowed; }}
  .pagination-controls {{ display:flex; align-items:center; gap:10px; margin-bottom:16px; }}
  #searchInput {{ flex:1; min-width:240px; }}
  #chatContainer {{ display:grid; grid-template-columns:repeat(auto-fit,minmax(320px,1fr)); gap:16px; }}
  .chat-card {{ background:#fff; padding:16px; border-radius:12px; border:1px solid #e5e7eb; display:none; }}
  .chat-card h3 {{ margin:0 0 10px; font-size:1.2rem; }}
  .chat-card p {{ margin:6px 0; line-height:1.4; }}
  .source-list {{ list-style:none; padding:0; margin:0; }}
  .source-list li {{ margin-bottom:12px; font-size:.95rem; }}
  .badge {{ display:inline-block; padding:3px 10px; background:#4338ca; color:#fff; border-radius:999px; font-size:.75rem; margin-right:6px; }}
  footer {{ text-align:center; padding:24px; font-size:.85rem; color:#475569; }}
  .chat-card .source-details {{ font-size:.85rem; color:#475569; margin-top:4px; display:block; }}
  .search-hit {{ background:#fef3c7; }}
  #noResults {{ color:#dc2626; font-weight:600; text-align:center; margin-top:12px; display:none; }}
</style>
</head>
<body>
<header>
  <h1>Chat Report</h1>
  <p>Generated on {timestamp} — {chat_count} chat(s).</p>
</header>
<main>
  <section class="section" id="overview">
    <h2>Keyword Metrics</h2>
    <div class="filters">
      <input type="text" id="searchInput" placeholder="Search chats by text, prompt, session, or source..." />
      <button onclick="resetSearch()">Clear</button>
    </div>
    <div class="metrics-grid">
      <div class="metric-card">
        <strong>{chat_count}</strong>
        Chats processed
      </div>
      <div class="metric-card">
        <strong>{term_total}</strong>
        Keyword mentions
      </div>
    </div>
    <h3>Topics</h3>
    <div class="metrics-grid">
      {first_topic_section}
    </div>
    <h3>Term breakdown</h3>
    <div class="metrics-grid">
      {term_cards}
    </div>
  </section>

  <section class="section" id="chats">
    <h2>Chats</h2>
    <div class="pagination-controls">
      <button id="prevPage" onclick="changePage(-1)">Previous</button>
      <span id="pageInfo">0 / 0</span>
      <button id="nextPage" onclick="changePage(1)">Next</button>
    </div>
    <div id="noResults">No chats match your search criteria.</div>
    <div id="chatContainer">
      {chat_cards}
    </div>
  </section>
</main>
<footer>
  <p>Report generated by chat_report.py</p>
</footer>

<script>
const searchInput = document.getElementById("searchInput");
const cards = Array.from(document.querySelectorAll(".chat-card"));
const pageSize = {page_size};
let filteredCards = cards.slice();
let currentPage = 1;

function renderPage() {{
  const totalPages = Math.max(1, Math.ceil(filteredCards.length / pageSize));
  if (currentPage > totalPages) {{
    currentPage = totalPages;
  }}
  cards.forEach(card => card.style.display = "none");
  const start = (currentPage - 1) * pageSize;
  const end = start + pageSize;
  filteredCards.slice(start, end).forEach(card => card.style.display = "block");
  document.getElementById("pageInfo").textContent = `${{currentPage}} / ${{totalPages}}`;
  document.getElementById("prevPage").disabled = currentPage === 1;
  document.getElementById("nextPage").disabled = currentPage === totalPages;
  document.getElementById("noResults").style.display = filteredCards.length === 0 ? "block" : "none";
}}

function filterChats(query) {{
  const value = query.trim().toLowerCase();
  filteredCards = cards.filter(card => card.getAttribute("data-search").includes(value));
  currentPage = 1;
  applySearchHighlights(value);
  renderPage();
}}

function applySearchHighlights(value) {{
  cards.forEach(card => {{
    card.classList.toggle("search-hit", value && card.getAttribute("data-search").includes(value));
  }});
}}

function resetSearch() {{
  searchInput.value = "";
  filterChats("");
}}

function changePage(delta) {{
  const totalPages = Math.max(1, Math.ceil(filteredCards.length / pageSize));
  currentPage = Math.min(Math.max(1, currentPage + delta), totalPages);
  renderPage();
}}

searchInput.addEventListener("input", () => filterChats(searchInput.value));
renderPage();
</script>
</body>
</html>
"""

CHAT_CARD_TEMPLATE = """
<div class="chat-card" data-search="{searchable}">
  <h3>{prompt}</h3>
  <p><strong>Chat ID:</strong> {chat_id}</p>
  <p><strong>Session ID:</strong> {session_id}</p>
  <p><strong>Question:</strong> {prompt}</p>
  <p><strong>Answer:</strong><br>{response}</p>
  <p><strong>Sources:</strong></p>
  <ul class="source-list">
    {source_items}
  </ul>
  <p><small>Created at: {created_at}</small></p>
</div>
"""

TERMS_CARD_TEMPLATE = """
<div class="metric-card">
  <strong>{count}</strong>
  {term}
</div>
"""

def parse_json_file(path: pathlib.Path) -> Iterable[Dict[str, Any]]:
    text = path.read_text(encoding="utf-8")
    try:
        data = json.loads(text)
        if isinstance(data, list):
            return data
        return [data]
    except json.JSONDecodeError:
        records = []
        for line in text.splitlines():
            line = line.strip()
            if not line:
                continue
            records.append(json.loads(line))
        return records

def parse_jsonl_file(path: pathlib.Path) -> Iterable[Dict[str, Any]]:
    with path.open(encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            yield json.loads(line)

def parse_csv_file(path: pathlib.Path) -> Iterable[Dict[str, Any]]:
    with path.open(encoding="utf-8", newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            full_message = row.get("full_message", "") or ""
            prompt = full_message
            response_data = {}
            json_start = full_message.find('{"text"')
            if json_start != -1:
                prompt = full_message[:json_start].strip()
                try:
                    response_data = json.loads(full_message[json_start:])
                except json.JSONDecodeError:
                    response_data = {}
            record = {
                "chat_id": row.get("chat_id", ""),
                "session_id": row.get("session_id", ""),
                "prompt": prompt,
                "created_at": row.get("created_at"),
                "text": json.dumps(response_data) if response_data else "",
                "raw_chat": {"response": response_data},
                "connection_information": row.get("widget", ""),
                "full_message": full_message,
                "parsed_question": prompt,
                "parsed_answer": response_data.get("text", ""),
                "metrics": {},
            }
            yield record

def normalize_text(value: Any) -> str:
    if isinstance(value, dict):
        return json.dumps(value, ensure_ascii=False)
    return str(value) if value is not None else ""

def build_searchable_text(record: Dict[str, Any]) -> str:
    parts = [
        record.get("prompt", ""),
        record.get("parsed_question", ""),
        normalize_text(record.get("parsed_answer")),
        normalize_text(record.get("text")),
        normalize_text(record.get("full_message")),
        normalize_text(record.get("translated_text")),
        normalize_text(record.get("raw_chat")),
        record.get("session_id", ""),
        ",".join(str(record.get("connection_information", "")).split()),
    ]
    return " ".join(parts).lower()

def combine_text_for_metrics(record: Dict[str, Any]) -> str:
    parts = [
        record.get("prompt", ""),
        record.get("parsed_question", ""),
        normalize_text(record.get("parsed_answer")),
        normalize_text(record.get("text")),
        normalize_text(record.get("full_message")),
        normalize_text(record.get("translated_text")),
        normalize_text(record.get("raw_chat")),
        record.get("session_id", ""),
        ",".join(str(record.get("connection_information", "")).split()),
    ]
    return " ".join(parts)

def build_source_items(raw_chat: Dict[str, Any]) -> str:
    sources = raw_chat.get("response", {})
    if isinstance(sources, str):
        try:
            sources = json.loads(sources).get("sources", [])
        except json.JSONDecodeError:
            sources = []
    else:
        sources = sources.get("sources", [])
    items = []
    for src in sources:
        title = escape(src.get("title", src.get("url", "source")))
        items.append(f"<li>{title}</li>")
    return "\n".join(items) if items else "<li>No sources recorded.</li>"

def load_terms(terms_path: pathlib.Path) -> List[Dict[str, Any]]:
    terms: List[Dict[str, Any]] = []
    if not terms_path or not terms_path.exists():
        return terms
    for line in terms_path.read_text(encoding="utf-8").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" in line:
            name, pattern = line.split("=", 1)
            name = name.strip()
            pattern = pattern.strip()
        else:
            name = line
            pattern = re.escape(line)
        if not name:
            name = pattern
        if not pattern:
            pattern = re.escape(name)
        try:
            compiled = re.compile(pattern)
        except re.error as exc:
            raise ValueError(f"Invalid regex for term '{name}': {exc}") from exc
        terms.append({"name": name, "pattern": compiled})
    return terms

def calculate_term_metrics(records: List[Dict[str, Any]], terms: List[Dict[str, Any]]) -> (Counter, Counter):
    counter = Counter()
    first_counter = Counter()
    for record in records:
        text = combine_text_for_metrics(record)
        first_match = None
        first_pos = None
        for term in terms:
            term_name = term["name"]
            pattern = term["pattern"]
            for match in pattern.finditer(text):
                counter[term_name] += 1
                start = match.start()
                if first_pos is None or start < first_pos:
                    first_pos = start
                    first_match = term_name
        if first_match:
            first_counter[first_match] += 1
    return counter, first_counter

def collect_records_from_path(path: pathlib.Path) -> List[Dict[str, Any]]:
    records = []
    if path.is_dir():
        for candidate in sorted(path.iterdir()):
            records.extend(_parse_candidate(candidate))
        return records
    if path.is_file():
        records.extend(_parse_candidate(path))
        return records
    raise FileNotFoundError(f"Path {path} is not a file or directory with supported extensions.")

def _parse_candidate(path: pathlib.Path) -> List[Dict[str, Any]]:
    if path.suffix.lower() == ".jsonl":
        return list(parse_jsonl_file(path))
    if path.suffix.lower() == ".json":
        return list(parse_json_file(path))
    if path.suffix.lower() == ".csv":
        return list(parse_csv_file(path))
    return []

def main():
    parser = argparse.ArgumentParser(description="Generate HTML report from chat JSON/CSV exports.")
    parser.add_argument("input_path", type=pathlib.Path, help="JSON/CSV file or directory containing exports.")
    parser.add_argument("--terms", type=pathlib.Path, default=None, help="Optional keywords file (name=regex per line).")
    parser.add_argument("--report", type=pathlib.Path, default=pathlib.Path("report"), help="Directory where HTML reports are written.")
    parser.add_argument("--page-size", type=int, default=10, help="Number of chats to show per page.")
    args = parser.parse_args()

    if not args.input_path.exists():
        parser.error(f"Path {args.input_path} does not exist.")
    if args.page_size < 1:
        parser.error("page-size must be at least 1.")

    records = collect_records_from_path(args.input_path)

    terms = load_terms(args.terms) if args.terms else []
    term_counts, first_term_counts = calculate_term_metrics(records, terms)
    term_cards = "\n".join(
        TERMS_CARD_TEMPLATE.format(term=escape(term["name"]), count=term_counts[term["name"]])
        for term in terms
    )
    if first_term_counts:
        first_topic_entries = "\n".join(
            TERMS_CARD_TEMPLATE.format(term=escape(name), count=count)
            for name, count in sorted(first_term_counts.items(), key=lambda item: item[1], reverse=True)
        )
    else:
        first_topic_entries = "<div class='metric-card'><strong>0</strong>No topic data yet</div>"

    chat_cards = []
    for record in records:
        searchable = escape(build_searchable_text(record))
        prompt = escape(record.get("parsed_question") or record.get("prompt", "") or "")
        response_value = record.get("parsed_answer")
        if not response_value and record.get("text"):
            try:
                response_value = json.loads(record.get("text")).get("text", "")
            except json.JSONDecodeError:
                response_value = record.get("text", "")
        response = escape(response_value or "").replace("\n", "<br>")
        chat_id = escape(record.get("chat_id", ""))
        session_id = escape(record.get("session_id", ""))
        raw_chat = record.get("raw_chat", {}) or {}
        sources_section = build_source_items(raw_chat)
        card = CHAT_CARD_TEMPLATE.format(
            searchable=searchable,
            prompt=prompt,
            chat_id=chat_id,
            session_id=session_id,
            response=response[:800] + ("…" if len(response) > 800 else ""),
            source_items=sources_section,
            created_at=escape(record.get("created_at", record.get("prompt_date", "unknown") or "unknown"))
        )
        chat_cards.append(card)

    html = HTML_TEMPLATE.format(
        timestamp=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC"),
        chat_count=len(records),
        term_total=sum(term_counts.values()),
        term_cards=term_cards,
        first_topic_section=first_topic_entries,
        chat_cards="\n".join(chat_cards),
        page_size=args.page_size,
    )

    report_dir = args.report
    report_dir.mkdir(parents=True, exist_ok=True)
    output_file = report_dir / "index.html"
    output_file.write_text(html, encoding="utf-8")
    print(f"Report written to {output_file.resolve()}")

if __name__ == "__main__":
    main()
